{"meta":{"title":"AmberStory","subtitle":"AmberStory","description":"just do it!","author":"AmberStory","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"npm script脚本命令学习总结","slug":"npm-script脚本命令学习总结","date":"2019-11-23T04:56:26.000Z","updated":"2019-11-23T09:53:59.000Z","comments":true,"path":"2019/11/23/npm-script脚本命令学习总结/","link":"","permalink":"http://yoursite.com/2019/11/23/npm-script脚本命令学习总结/","excerpt":"运用好npm脚本\b命令可以帮助快速按需启动程序。 简介：npm run命令可以执行package.json文件里scripts字段里定义的脚本命令。当执行npm run的时候，会自动创建一个Shell，这个Shell会将当前目录的node_modules/.bin子目录绝对路径加入PATH环境变量中，执行结束后，再将PATH变量恢复原样。node_modules/.bin目录下的脚本全部为可执行文件，所以在定义脚本命令的时候，可以直接调用该目录下的脚本名，不必加上路径。比如当前项目依赖cross-env，可以直接执行该命令：","text":"运用好npm脚本\b命令可以帮助快速按需启动程序。 简介：npm run命令可以执行package.json文件里scripts字段里定义的脚本命令。当执行npm run的时候，会自动创建一个Shell，这个Shell会将当前目录的node_modules/.bin子目录绝对路径加入PATH环境变量中，执行结束后，再将PATH变量恢复原样。node_modules/.bin目录下的脚本全部为可执行文件，所以在定义脚本命令的时候，可以直接调用该目录下的脚本名，不必加上路径。比如当前项目依赖cross-env，可以直接执行该命令：12345&#123; \"scripts\": &#123; \"build\": \"cross-env NODE_ENV=test\" &#125;&#125; npm脚本就是Shell脚本，所以只要是Shell中可以执行的脚本，都可以写在scripts命令中。 传参向npm传入参数，需要使用--说明符：1npm run build --config webpack1.config.js 说明：config为参数名，webpack1.config.js为参数值，这条命令的意思是执行build命令的时候读取webpack1.config.js文件配置（默认是使用名为webpack.config.js的配置） 执行顺序如果npm中一个命令需要执行多个任务，需要明确它们的执行顺序。如果是并行执行（即同时执行多个任务），可以使用&amp;符号。123\"scripts\": &#123; \"test\": \"install &amp; build\" &#125; 如果是继发执行（即前一个任务执行完成之后，才开始执行下一个任务），可以使用&amp;&amp;符号。123\"scripts\": &#123; \"test\": \"build &amp;&amp; upload\" &#125; 以上方法同样适用于多个命令。12npm run script1 &amp; npm run script2npm run script1 &amp;&amp; npm run script2 钩子npm有pre和host两个钩子，一个是某个命令之前执行，一个是之后执行，比如build命令的钩子是prebuild和postbuild。12345\"scripts\": &#123; \"prebuild\": \"echo I run before build script\", \"build\": \"cross-env NODE_ENV=prod\", \"postbuild\": \"echo I run after build script\" &#125; 以上命令，当我们输入npm run build的时候，控制台会先打印“I run before build script”，接着执行cross-env NODE_ENV=prod命令，然后打印“I run after build script”。 注意： 测试发现双重post不生效，比如postpostbuild，但是双重pre可以生效，比如preprebuild，不过尽量还是不要定义以pre和post开头的命令。 环境变量npm会设置很多环境变量，可以通过npm run env查看，其中package.json中设置的字段，都会被自动添加上npm_package_的前缀，比如scripts里的build字段就会被编译成npm_package_scripts_build。npm的所有环境变量可以通过npm run env来查看。 注意： 可以在命令语句中定义变量，形式是“名称=值”，比如执行语句中加入“NODE_ENV=true”会成为环境变量，“MOCK=true”也是环境变量，都可以通过process.env来获取； 如果命令上有“:”，也会被替换成“_”； 如果对象的值是数组，则编译之后是按下标作为key。比如{&quot;pretest&quot;: [&quot;a&quot;,&quot;b&quot;]}会被编译成&quot;npm_package_pretest_0&quot;: &quot;a&quot;,和&quot;npm_package_pretest_1&quot;: &quot;b&quot;； npm_lifecycle_event字段用于标识当前处于哪一个阶段（所谓的生命周期），比如执行prebuild的时候，npm_lifecycle_event的值为prebuild，我们可以通过process.env.npm_lifecycle_event取值。 进阶：commander有时候我们不希望在scripts中定义很多命令，但是又希望可以根据需求执行不同的脚本，这个时候可以在同一个命令中传入不同的参数来区分执行什么操作。我们可以通过process.argv获取启动node.js进程时传入的命令行参数，然后通过js语法判断传入的参数值，最后执行相应的操作。（注意：当我们启动node.js进程的时候，process.argv获取第一个参数其实是node的安装路径，第二个参数是执行文件的所在路径，从第三个参数开始才是我们实际希望传入的参数。）这里提供一个快速取出参数的方法，利用commander插件。第一步：安装。npm i commander --save；第二步：引入。在node启动的程序文件中进入，const program = require(&#39;commander&#39;);第三步：使用。program.option(&#39;-u, --upload&#39;).parse(process.argv);第四步：判断参数。if(program.upload) { upload(); }然后当我们执行node index.js -u的时候，就会使program.upload为true，从而执行if里面的函数。 更多使用方法请参数：https://www.npmjs.com/package/commander** 参考文档： http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html https://juejin.im/post/5cb3f1ef5188256d917874ff https://www.npmjs.com/package/commander","categories":[],"tags":[{"name":"npm JavaScript","slug":"npm-JavaScript","permalink":"http://yoursite.com/tags/npm-JavaScript/"}]},{"title":"微信小程序开发学习笔记","slug":"微信小程序开发学习笔记","date":"2019-11-14T02:17:42.000Z","updated":"2019-11-16T03:46:56.000Z","comments":true,"path":"2019/11/14/微信小程序开发学习笔记/","link":"","permalink":"http://yoursite.com/2019/11/14/微信小程序开发学习笔记/","excerpt":"","text":"page.json语法 JSON文件被包含在一个大括号中：{} JSON的key必须使用双引号包裹：“” JSON的value可以包含：数字，字符串，bool，数组，对象，null，六种类型 dataset与markdataset: 在 WXML 中，自定义的数据以 data- 开头，多个单词由连字符 - 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。mark: 当事件触发时，事件冒泡路径上所有的 mark 会被合并，并返回给事件回调函数。 但是，如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。 在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark。 节点的mark不会做连字符和大小写转换。 selectorQuery在自定义组件或包含自定义组件的页面中，推荐使用 this.createSelectorQuery 来代替 wx.createSelectorQuery ，这样可以确保在正确的范围内选择节点。 启用屏幕选择支持手机：使小程序中的页面支持屏幕旋转的方法是：在 app.json 的 window 段中设置 “pageOrientation”: “auto” ，或在页面 json 文件中配置 “pageOrientation”: “auto” 。iPad：在 app.json 中添加 “resizable”: true 。注意：在 iPad 上不能单独配置某个页面是否支持屏幕旋转。 Component自定义组件在 properties 定义段中，属性名采用驼峰写法（propertyName）；在 wxml 中，指定属性值时则对应使用连字符写法（component-tag-name property-name=”attr value”），应用于数据绑定时采用驼峰写法（attr=””）。 插入节点solt默认情况下，一个组件的wxml中只能有一个slot。需要使用多slot时，可以在组件js中声明启用。12345Component(&#123; options: &#123; multipleSlots: true // 在组件定义时的选项中启用多slot支持 &#125;,&#125;) 此时，可以在这个组件的wxml中使用多个slot，以不同的 name 来区分。 组件选择器 a { } / 在组件中不能使用 / [a] { } / 在组件中不能使用 / button { } / 在组件中不能使用 / .a &gt; .b { } / 除非 .a 是 view 组件节点，否则不一定会生效 / 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。12345Component(&#123; options: &#123; styleIsolation: 'shared' // 默认值是isolation，表示启用样式隔离，官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html &#125;&#125;)","categories":[],"tags":[{"name":"weixin","slug":"weixin","permalink":"http://yoursite.com/tags/weixin/"}]},{"title":"vue的watch用法总结","slug":"vue-watch用法总结","date":"2019-11-03T11:27:47.000Z","updated":"2019-11-03T12:03:15.000Z","comments":true,"path":"2019/11/03/vue-watch用法总结/","link":"","permalink":"http://yoursite.com/2019/11/03/vue-watch用法总结/","excerpt":"watch可用于监听vue实例数据的变化，下面详细总结一下watch的用法。 deep属性当变异对象发生变化的时候，vue并检查不到这种变化，所以不会触发watch函数来执行相应操作，这个时候我们使用deep属性，进行深入监听（注意：数组的变化不需要使用该属性）。12345678910111213141516data() &#123; return &#123; obj: &#123; name: 'Amber', age: 18 &#125; &#125;&#125;,watch: &#123; obj: &#123; handler() &#123; console.log('obj changed'); &#125;, deep: true &#125;&#125;","text":"watch可用于监听vue实例数据的变化，下面详细总结一下watch的用法。 deep属性当变异对象发生变化的时候，vue并检查不到这种变化，所以不会触发watch函数来执行相应操作，这个时候我们使用deep属性，进行深入监听（注意：数组的变化不需要使用该属性）。12345678910111213141516data() &#123; return &#123; obj: &#123; name: 'Amber', age: 18 &#125; &#125;&#125;,watch: &#123; obj: &#123; handler() &#123; console.log('obj changed'); &#125;, deep: true &#125;&#125; 当obj的属性发生变化的时候，就会打印“obj changed”。但这种写法只要obj发生改变，就会触发，容易造成内容溢出，如果只是想单纯的监听某一个属性的变化，可以改写成路径监听的方式。 路径监听改写上述代码：123456789101112131415data() &#123; return &#123; obj: &#123; name: 'Amber', age: 18 &#125; &#125;&#125;,watch: &#123; 'obj.a': &#123; handler() &#123; console.log('obj changed'); &#125;, &#125;&#125; 这样只有在obj.a属性发生变化的时候，才会触发watch函数。注意，路径得以字符串的形式表示。 immediate属性如果希望watch在最初绑定的时候就执行，可以使用immediate属性。1234567891011121314151617data() &#123; return &#123; obj: &#123; name: 'Amber', age: 18 &#125; &#125;&#125;,watch: &#123; obj: &#123; handler() &#123; console.log('obj changed'); &#125;, immediate: true, deep: true &#125;&#125; 参考文献： https://cn.vuejs.org/v2/api/#vm-watch https://www.jianshu.com/p/fd68e178f71e","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"watch","slug":"watch","permalink":"http://yoursite.com/tags/watch/"}]},{"title":"启动服务时抛错：permission denied","slug":"启动服务时抛错：permission-denied","date":"2019-10-28T02:06:42.000Z","updated":"2019-10-29T01:38:07.000Z","comments":true,"path":"2019/10/28/启动服务时抛错：permission-denied/","link":"","permalink":"http://yoursite.com/2019/10/28/启动服务时抛错：permission-denied/","excerpt":"","text":"遇到的问题：启动项目时总是报错：某个路径下文件没有访问权限，permission denied。解决方案：1、在启动服务的命令前加上sudo命令，比如：sudo npm start；2、将没有权限的这个目录权限改为777，即chmod 777；","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"微信分享设置无效（SPA/history模式）","slug":"微信分享设置无效","date":"2019-10-25T12:18:41.000Z","updated":"2019-10-25T13:57:44.000Z","comments":true,"path":"2019/10/25/微信分享设置无效/","link":"","permalink":"http://yoursite.com/2019/10/25/微信分享设置无效/","excerpt":"问题描述：ios环境下，在app.vue文件中设置完分享信息后，切换页面也可以正常分享，但是安卓下分享信息只能在首页生效，切换页面之后设置的分享信息失效。 微信分享步骤1、绑定域名，登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”；2、引入JS文件：http://res2.wx.qq.com/open/js/jweixin-1.4.0.js；","text":"问题描述：ios环境下，在app.vue文件中设置完分享信息后，切换页面也可以正常分享，但是安卓下分享信息只能在首页生效，切换页面之后设置的分享信息失效。 微信分享步骤1、绑定域名，登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”；2、引入JS文件：http://res2.wx.qq.com/open/js/jweixin-1.4.0.js；3、通过config接口注入权限验证配置；12345678wx.config(&#123; debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: '', // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: '', // 必填，生成签名的随机串 signature: '',// 必填，签名 jsApiList: [] // 必填，需要使用的JS接口列表&#125;); 4、通过ready接口处理成功验证；1234567891011wx.ready(function () &#123; //需在用户可能点击分享按钮前就先调用 wx.updateAppMessageShareData(&#123; title: '', // 分享标题 desc: '', // 分享描述 link: '', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: '', // 分享图标 success: function () &#123; // 设置成功 &#125; &#125;)&#125;); 已经完全按照文档的步骤设置过了，但是配置的分享信息还是没有生效，文档里提到“wx.onMenuShareAppMessage”这个api即将废弃，但是没有指明什么时候废弃，这个api也是用于“分享给朋友”的，那么我们试一下在wx.updateAppMessageShareData调用失败的情况下再尝试调用wx.onMenuShareAppMessage试一下：123456789101112131415161718192021222324wx.ready(function () &#123; //需在用户可能点击分享按钮前就先调用 wx.updateAppMessageShareData(&#123; title: '', // 分享标题 desc: '', // 分享描述 link: '', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: '', // 分享图标 success: function () &#123; // 设置成功 &#125;, fail: function() &#123; if (wx.onMenuShareAppMessage) &#123; wx.onMenuShareAppMessage(&#123; title: '', // 分享标题 desc: '', // 分享描述 link: '', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: '', // 分享图标 success: function () &#123; // 设置成功 &#125; &#125;) &#125; &#125; &#125;)&#125;); 这次能够分享设置的配置信息生效了，但是新的问题又来了：安卓下，分享配置信息只能在进入的第一个页面生效，比如最先进入了A页面，如果再从A页面跳转到B页面，配置信息又失效了。经过调研发现，ios和安卓下对落地页（浏览器认为的页面）的认知不一样。安卓下，每次路由跳转会产生新的落地页，但是ios始终保持最初进入页面时的url为落地页，这就导致我们切换页面之后，安卓下产生了新的落地页，但是我们的分享信息是在上一个落地页上进行配置的，所以安卓下的配置信息实现。解决方法：我们可以在每次路由切换的时候重新调用微信分享api即可。12345678910// 通过vue-router的后置钩子判断路由是否更新router.afterEach((to) =&gt; &#123; // 防止阻塞页面打开 setTimeout(() =&gt; &#123; // 如果在微信环境下，且是安卓手机，就重新调用微信分享方法 if (webviewType.isWx &amp;&amp; platform.osName() === 'android') &#123; wx.share(); // 这里的share方法是自行封装过的 &#125; &#125;, 0); &#125;); 注意：上述代码将微信分享方法放在setTimeout中调用是因为，必须等到页面完全切换之后，重新调用才能生效 至此，解决了微信分享调用失败的问题。 参考文档： 微信分享 总结（SPA/history模式） 微信分享朋友、朋友圈 微信js-sdk使用说明","categories":[],"tags":[{"name":"js-sdk","slug":"js-sdk","permalink":"http://yoursite.com/tags/js-sdk/"},{"name":"wx","slug":"wx","permalink":"http://yoursite.com/tags/wx/"}]},{"title":"微信sdk签名错误：invalid signature","slug":"微信sdk签名错误：invalid-signature","date":"2019-10-25T11:23:39.000Z","updated":"2019-10-29T01:56:25.000Z","comments":true,"path":"2019/10/25/微信sdk签名错误：invalid-signature/","link":"","permalink":"http://yoursite.com/2019/10/25/微信sdk签名错误：invalid-signature/","excerpt":"最近一段时间遇到个十分头疼的问题，微信小程序环境下进行微信签名的时候一直报错：invalid signature。在严格按照官方文档提供的签名的方法进行后，还是给出这个提示。另外获取js-sdk配置信息时，传入的url必须和当前页面的url保持一致，但不能保留url上携带的hash值。检查这条规则，也是符合的，url是通过location.href获取的，没有问题。后来又经过反复排查，反复试验，才找到问题真相：传入的url并不是进入页面时拿到的url，即使是通过location.href动态获取的。 location.href取到的不是页面真实url","text":"最近一段时间遇到个十分头疼的问题，微信小程序环境下进行微信签名的时候一直报错：invalid signature。在严格按照官方文档提供的签名的方法进行后，还是给出这个提示。另外获取js-sdk配置信息时，传入的url必须和当前页面的url保持一致，但不能保留url上携带的hash值。检查这条规则，也是符合的，url是通过location.href获取的，没有问题。后来又经过反复排查，反复试验，才找到问题真相：传入的url并不是进入页面时拿到的url，即使是通过location.href动态获取的。 location.href取到的不是页面真实url 大坑：通过vue-router进行页面管理的项目，如果页面url中包含参数，但是这些参数又没有经过encodeURIComponent编码，比如https://www.test.com?q=a:1，那么页面打开后通过location.href取得的url，实际上是https://www.test.com?q=a%3A1，这是vue-router的默认行为（可参考下方vue-router源码），自动为url上的参数encode。此时拿着encode后的url获取js-sdk配置信息的时候，在ios下没有问题，安卓下就会出现invalid signature的错误提示。 vue-router源码12345678910111213141516171819202122232425262728293031 function stringifyQuery (obj) &#123; let res = obj ? Object.keys(obj).map((key) =&gt; &#123; let val = obj[key]; if (val === undefined) &#123; return ''; &#125; if (val === null) &#123; return encodeURIComponent(key); &#125; if (Array.isArray(val)) &#123; let result = []; val.forEach((val2) =&gt; &#123; if (val2 === undefined) &#123; return; &#125; if (val2 === null) &#123; result.push(encodeURIComponent(key)); &#125; else &#123; result.push(`$&#123;encodeURIComponent(key)&#125;=$&#123;encodeURIComponent(val2)&#125;`); &#125; &#125;); return result.join('&amp;'); &#125; return `$&#123;encodeURIComponent(key)&#125;=$&#123;encodeURIComponent(val)&#125;`; &#125;).filter((x) =&gt; x.length &gt; 0).join('&amp;') : null; return res ? (`?$&#123;res&#125;`) : '';&#125; 解决方案可以修改上述源码，在创建VueRouter对象的时候传入修改后的方法，覆盖vue-router默认行为，比如new VueRouter({ stringifyQuery })， 相关api文档。如果你的微信签名一直提示“invalid signature”错误，其他配置又完全正常的情况下，请仔细检查url，基本都是url的问题。 附上一个整理的超级详细的文档：https://www.fengerzh.com/jssdk-invalid-signature/ 微信开发文档：https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html","categories":[],"tags":[{"name":"js-sdk","slug":"js-sdk","permalink":"http://yoursite.com/tags/js-sdk/"},{"name":"vue-router","slug":"vue-router","permalink":"http://yoursite.com/tags/vue-router/"}]},{"title":"v-model语法糖","slug":"v-model语法糖","date":"2019-10-20T12:01:24.000Z","updated":"2019-10-20T13:12:03.000Z","comments":true,"path":"2019/10/20/v-model语法糖/","link":"","permalink":"http://yoursite.com/2019/10/20/v-model语法糖/","excerpt":"v-model 本质上是语法糖，它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：text 和 textarea 元素使用 value 属性和 input 事件；checkbox 和 radio 使用 checked 属性和 change 事件；select 字段将 value 作为 prop 并将 change 作为事件。 相当于在children组件内部，props中有一个名为value的属性，且children上有一个input事件，即 子组件：","text":"v-model 本质上是语法糖，它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：text 和 textarea 元素使用 value 属性和 input 事件；checkbox 和 radio 使用 checked 属性和 change 事件；select 字段将 value 作为 prop 并将 change 作为事件。 相当于在children组件内部，props中有一个名为value的属性，且children上有一个input事件，即 子组件：123456789101112131415&lt;template&gt; &lt;input type=\"text\" :value=\"value\" @input=\"inputHandle($event.target.value)\" /&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; value: '', &#125; methods: &#123; inputHandle(value) &#123; return this.$emit(\"input\", value); &#125; &#125; &#125;&lt;/script&gt; v-model修饰符 .lazy在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步，而非input时进行更新，例如&lt;input v-model.lazy=&quot;msg&quot;&gt;。 .number如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符，例如&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;。 .trim如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符，例如&lt;input v-model.trim=&quot;msg&quot;&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"深拷贝和浅拷贝","slug":"深拷贝和浅拷贝","date":"2019-10-19T03:42:51.000Z","updated":"2019-10-20T11:54:11.000Z","comments":true,"path":"2019/10/19/深拷贝和浅拷贝/","link":"","permalink":"http://yoursite.com/2019/10/19/深拷贝和浅拷贝/","excerpt":"JavaScript的变量包含基本类型的值和引用类型的值。其中基本类型值是存储在栈中的一些简单的数据段；引用类型值是引用类型的实例，引用类型是一种数据结构。JavaScript基本类型包括：String、Number、Boolean、Null、Undefined、Symbol。JavaScript引用类型包括：Object、Array、Date、Function、RegExp等。 引用类型复制12345obj1 = &#123;a: 1&#125;;obj2 = obj1;obj2.a = 2;console.log(obj1.a); // 2console.log(obj2.a); // 2","text":"JavaScript的变量包含基本类型的值和引用类型的值。其中基本类型值是存储在栈中的一些简单的数据段；引用类型值是引用类型的实例，引用类型是一种数据结构。JavaScript基本类型包括：String、Number、Boolean、Null、Undefined、Symbol。JavaScript引用类型包括：Object、Array、Date、Function、RegExp等。 引用类型复制12345obj1 = &#123;a: 1&#125;;obj2 = obj1;obj2.a = 2;console.log(obj1.a); // 2console.log(obj2.a); // 2 由以上示例可以看出，当改变obj2中a的值的时候，obj1中a的值也发生了同样的变化。因为引用类型变量的值实际上是一个指针，指向存储在堆内存中的对象。当把obj1的值赋给obj2时，只是复制出一个指向同一堆内存的指针，所以当通过obj2操作堆内存中的对象时，obj1取到的值也同样发生了改变。 浅拷贝 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 Object.assign()ES6提供的浅拷贝方法，语法：Object.assign(target, …soruces);接收的第一个参数是拷贝的目标，剩下的是拷贝的源对象（可以是多个）。1234567obj1 = &#123;a: 1, msg: &#123; name: 'Amber', age: 20 &#125;&#125;;obj2 = &#123;&#125;;Object.assign(obj2, obj1);obj1.a = 2;obj1.msg.age = 22;console.log(obj1); // &#123; a: 2, msg: &#123; name: 'Amber', age: 22 &#125;&#125;console.log(obj2); // &#123; a: 1, msg: &#123; name: 'Amber', age: 22 &#125;&#125; 对于值依然是对象的元素，属于浅拷贝，改变一个对象的值，目标对象的值也会变化。 扩展运算符利用扩展运算符可以在构造字面量对象时,进行克隆或者属性拷贝，语法：cloneObj = { …obj };123456789obj = &#123;a:1,b:&#123;c:1&#125;&#125;obj2 = &#123;...obj&#125;;obj.a=2;console.log(obj); //&#123;a:2,b:&#123;c:1&#125;&#125;console.log(obj2); //&#123;a:1,b:&#123;c:1&#125;&#125;obj.b.c = 2;console.log(obj); //&#123;a:2,b:&#123;c:2&#125;&#125;console.log(obj2); //&#123;a:1,b:&#123;c:2&#125;&#125; 扩展运算符和Object.assign一样，如果一个属性的值仍然是对象的话，属于浅拷贝。 深拷贝 将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象。 JSON.stringify()JSON.stringify()是目前前端开发过程中最常用的深拷贝方式，原理是把一个对象序列化成为一个JSON字符串，将对象的内容转换成字符串的形式再保存在磁盘上，再用JSON.parse()反序列化将JSON字符串变成一个新的对象。123456obj1 = &#123;a: 1, msg: &#123; name: 'Amber', age: 20 &#125;&#125;;obj2 = JSON.parse(JSON.stringify(obj1));obj1.a = 2;obj1.msg.age = 22;console.log(obj1); // &#123; a: 2, msg: &#123; name: 'Amber', age: 22 &#125;&#125;console.log(obj2); // &#123; a: 1, msg: &#123; name: 'Amber', age: 20 &#125;&#125; 注意：深拷贝日期类型，会变成string类型；深拷贝RegExp引用类型，会变成空对象。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"for in和for of","slug":"for-in和for-of","date":"2019-10-15T14:58:21.000Z","updated":"2019-10-20T11:57:50.000Z","comments":true,"path":"2019/10/15/for-in和for-of/","link":"","permalink":"http://yoursite.com/2019/10/15/for-in和for-of/","excerpt":"for…infor…in是es5标准，以任意顺序遍历一个对象的除Symbol以外的可枚举属性（循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）)。如果只要考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或执行 hasOwnProperty() 来确定某属性是否是对象本身的属性（也能使用propertyIsEnumerable）。","text":"for…infor…in是es5标准，以任意顺序遍历一个对象的除Symbol以外的可枚举属性（循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）)。如果只要考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或执行 hasOwnProperty() 来确定某属性是否是对象本身的属性（也能使用propertyIsEnumerable）。 示例12345678910111213var car = &#123;a: 1, b: 2, c:3&#125;;function ColorCar() &#123; this.color = 'red';&#125;ColorCar.prototype = car;var obj = new ColorCar();for(var prop in obj) &#123; if(obj.hasOwnProperty(prop)) &#123; console.log('own prop:', prop); // own prop: color continue; &#125; console.log('extend prop:', prop); // extend prop:a extend prop:b extend prop:c&#125; 提示：for…in不应该用于迭代一个 Array，因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素。 for…offor…of 是es6标准，遍历可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）要迭代的数据。 示例1234arr = [3,5,7];for (item of arr) &#123; console.log('item:', item); // item: 3 item:5 item:7&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"es5","slug":"es5","permalink":"http://yoursite.com/tags/es5/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"locationStorage和sessionStorage","slug":"locationStorage和sessionStorage","date":"2019-10-15T14:38:53.000Z","updated":"2019-10-15T15:42:57.000Z","comments":true,"path":"2019/10/15/locationStorage和sessionStorage/","link":"","permalink":"http://yoursite.com/2019/10/15/locationStorage和sessionStorage/","excerpt":"locationStorage和sessionStorage都属于本地存储，存储的数据都保存在浏览器会话中，二者的区别在于：locationStorage存储的数据可以长期保留，除非强制清除；而sessionStorage存储的数据仅存在于页面会话期间，即当页面关闭之后，sessionStorage中的数据就会被清除。","text":"locationStorage和sessionStorage都属于本地存储，存储的数据都保存在浏览器会话中，二者的区别在于：locationStorage存储的数据可以长期保留，除非强制清除；而sessionStorage存储的数据仅存在于页面会话期间，即当页面关闭之后，sessionStorage中的数据就会被清除。 用法// 保存数据到 localStoragelocalStorage.setItem(‘key’, ‘value’); // 从 localStorage 删除保存的数据localStorage.removeItem(‘key’, ‘value’); // 保存数据到 sessionStoragesessionStorage.setItem(‘key’, ‘value’); // 从 sessionStorage 获取数据let data = sessionStorage.getItem(‘key’); // 从 sessionStorage 删除保存的数据sessionStorage.removeItem(‘key’); // 从 sessionStorage 删除所有保存的数据sessionStorage.clear();","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"storage","slug":"storage","permalink":"http://yoursite.com/tags/storage/"}]},{"title":"使用hexo构建博客","slug":"使用hexo构建博客","date":"2019-10-15T14:29:08.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/10/15/使用hexo构建博客/","link":"","permalink":"http://yoursite.com/2019/10/15/使用hexo构建博客/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"主题使用教程","slug":"主题使用教程","date":"2019-09-22T13:36:18.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/09/22/主题使用教程/","link":"","permalink":"http://yoursite.com/2019/09/22/主题使用教程/","excerpt":"","text":"hexo-theme-yiliahttps://github.com/litten/hexo-theme-yilia","categories":[],"tags":[]},{"title":"git关联远程仓库","slug":"git关联远程仓库","date":"2019-09-22T13:15:25.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/09/22/git关联远程仓库/","link":"","permalink":"http://yoursite.com/2019/09/22/git关联远程仓库/","excerpt":"","text":"git remote add &lt;远程仓库名&gt; &lt;远程仓库地址&gt;比如：git remote add origin https://github.com/AmberStory/AmberStory.github.io.git&lt;远程仓库名&gt;可以任意起，不过一般默认远程仓库名是origin 一个项目可以有多个远程仓库，只需要通过git remote add [shortname] [url]命令添加即可。 拉取远程仓库代码：git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;例如：git pull dp-mp release_1.0.0 向远程提交代码：git push &lt;远程仓库名&gt; &lt;需要push的分支名&gt;","categories":[],"tags":[]},{"title":"一句话搞定元素样式","slug":"一句话搞定元素样式","date":"2019-09-22T12:35:39.000Z","updated":"2019-10-15T15:44:38.000Z","comments":true,"path":"2019/09/22/一句话搞定元素样式/","link":"","permalink":"http://yoursite.com/2019/09/22/一句话搞定元素样式/","excerpt":"","text":"相邻元素之间加分割线如下图：实现方法：利用兄弟选择器div + div { border-top: 1px solid;}","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"promise踩坑记","slug":"promise踩坑记","date":"2019-09-02T00:58:57.000Z","updated":"2019-10-15T15:44:22.000Z","comments":true,"path":"2019/09/02/promise踩坑记/","link":"","permalink":"http://yoursite.com/2019/09/02/promise踩坑记/","excerpt":"记得return采用箭头函数的写法：12let p = new Promise((res)=&gt;&#123; res() &#125;);p.then((res) =&gt; success(res)); then里面的回调函数此时没有加花括号，其实是以下写法的简写：12let p = new Promise((res)=&gt;&#123; res() &#125;);p.then((res) =&gt; &#123; return success(res); &#125;); 加上花括号之后一定要加return，否则如果success函数返回的是一个promise，外面的函数是感知不到的，比如以下示例：123456789let p = new Promise((res)=&gt;&#123; res() &#125;);p.then((res) =&gt; &#123; Promise.reject('fail') &#125;).then(success, fail);function success() &#123; console.log('success');&#125;function fail() &#123; console.log('fail');&#125; 此时第一个then已经抛reject了，但是由于没有return，第二个then感知不到，所以把第一个then的返回值当普通函数处理，此时会进入第二个then的success函数里，但是我们预期的是希望进到fail函数里。","text":"记得return采用箭头函数的写法：12let p = new Promise((res)=&gt;&#123; res() &#125;);p.then((res) =&gt; success(res)); then里面的回调函数此时没有加花括号，其实是以下写法的简写：12let p = new Promise((res)=&gt;&#123; res() &#125;);p.then((res) =&gt; &#123; return success(res); &#125;); 加上花括号之后一定要加return，否则如果success函数返回的是一个promise，外面的函数是感知不到的，比如以下示例：123456789let p = new Promise((res)=&gt;&#123; res() &#125;);p.then((res) =&gt; &#123; Promise.reject('fail') &#125;).then(success, fail);function success() &#123; console.log('success');&#125;function fail() &#123; console.log('fail');&#125; 此时第一个then已经抛reject了，但是由于没有return，第二个then感知不到，所以把第一个then的返回值当普通函数处理，此时会进入第二个then的success函数里，但是我们预期的是希望进到fail函数里。 promise的return思考以下两组代码：12345678910new Promise((resolve, reject) =&gt; &#123; return resolve(1);&#125;).then(r =&gt; &#123; console.log(r); return Promise.resolve(3);&#125;).then(r =&gt; &#123; console.log(r);&#125;); 12345678910new Promise((resolve, reject) =&gt; &#123; return resolve(1);&#125;).then(r =&gt; &#123; console.log(r); return 3;&#125;).then(r =&gt; &#123; console.log(r);&#125;); 以上两组代码都打印出：1 3 resolve和reject等价实例：123456789let p = new Promise((res)=&gt;&#123; res() &#125;);p.then(success, fail).catch(err =&gt; console.error(err));function success() &#123; console.log('success'); throw new Error('出错了');&#125;function fail() &#123; console.log('fail');&#125; 此时在success函数里抛错之后，并不会进入fail函数，而是会被catch捕获，但是，如果第一个promise出错了呢12345678let p = new Promise((res)=&gt;&#123; throw new Error('promise就出错了') &#125;);p.then(success, fail).catch(err =&gt; console.error(err));function success() &#123; console.log('success');&#125;function fail() &#123; console.log('fail');&#125;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"}]},{"title":"日期转时间戳","slug":"日期转时间戳","date":"2019-09-02T00:57:39.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/09/02/日期转时间戳/","link":"","permalink":"http://yoursite.com/2019/09/02/日期转时间戳/","excerpt":"","text":"日期格式转时间戳的方式，网上大多数写法如下：12const str = '2019-08-28 00:00:00';const stamp = new Date(str).getTime(); 这种写法在google浏览器下运行没有问题，于是我按照这种写法把代码上线了，结果，自己挖的坑自己填。安卓手机没有问题，但是ios手机上，这种写法的日期被转换之后直接NaN了，后来我又在Safari浏览器测试了一下，果然，返回也是NaN。 兼容性写法：12const str = '2019/08/28 00:00:00';const stamp = new Date(str).getTime(); 将“-”替换成“/”就可以了，ios、安卓下都没有问题。","categories":[],"tags":[{"name":"JavaScript Date","slug":"JavaScript-Date","permalink":"http://yoursite.com/tags/JavaScript-Date/"}]},{"title":"SVG实现倒计时动效","slug":"SVG实现倒计时","date":"2019-08-04T15:32:00.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/08/04/SVG实现倒计时/","link":"","permalink":"http://yoursite.com/2019/08/04/SVG实现倒计时/","excerpt":"","text":"利用strke-dasharray创建虚线，结合stroke-dashoffset控制虚线开始的位置，实现倒计时条滑动的效果。strke-dasharray接收两个参数，第一个表示虚线的长度，第二个表示虚线之间的间隔，当两个值相等的时候，只需要给一个参数。stroke-dashoffset指定线段的起始位置偏移量。整数从起始位置向前偏移，负数向后偏移。 利用requestAnimationFrame计算剩余时间：12345678910111213141516window.requestAnimationFrame(this.timeFlow);timeFlow(time) &#123; if (!time) return; if (!this.record) this.record = time; const flowTime = time - this.record; this.record = time; const remain = this.remainTime - Math.floor(flowTime); if (remain &gt; 0) &#123; this.remainTime = remain; this.raf = window.requestAnimationFrame(this.timeFlow); &#125; else &#123; this.remainTime = 0; &#125;&#125;","categories":[],"tags":[{"name":"SVG","slug":"SVG","permalink":"http://yoursite.com/tags/SVG/"}]},{"title":"Linux命令","slug":"Linux命令","date":"2019-07-30T10:58:31.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/07/30/Linux命令/","link":"","permalink":"http://yoursite.com/2019/07/30/Linux命令/","excerpt":"curl-v-v参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。$ curl -v http://example -b-b参数可以用来指定cookie，也可以用过–cookie来指定cookie的值。$ curl -b &quot;token=PS-1YW8oJ65LIc&quot; http://example.com","text":"curl-v-v参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。$ curl -v http://example -b-b参数可以用来指定cookie，也可以用过–cookie来指定cookie的值。$ curl -b &quot;token=PS-1YW8oJ65LIc&quot; http://example.com 参考文档 https://itbilu.com/linux/man/4yZ9qH_7X.html http://www.ruanyifeng.com/blog/2011/09/curl.html gzipgzip file 可以用来压缩文件gzip -dv file 用来解压压缩后的文件 参考文献 http://man.linuxde.net/gzip","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"正则的魅力","slug":"正则的魅力","date":"2019-07-30T10:53:12.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/07/30/正则的魅力/","link":"","permalink":"http://yoursite.com/2019/07/30/正则的魅力/","excerpt":"$0-$9$1, $2, $3, $4, $5, $6, $7, $8, $9 的属性是用于匹配正则表达式中包含括号的子串。例举1：str = &#39;https://baidu.com/abc/test/home&#39;; reg = /(https|http):\\/\\/baidu.com\\/(.*)/; str.match(reg); 打印：RegExp.$1 // httpsRegExp.$2 // abc/test/homeRegExp.$3 // ‘’分析原因：reg正则表达式中第一个括号中的规则匹配到的str中的内容是‘https’；reg正则表达式中第二个括号中的规则匹配到的str中的内容是‘abc/test/home’；没有第三个括号，所以RegExp.$3匹配的内容为空。","text":"$0-$9$1, $2, $3, $4, $5, $6, $7, $8, $9 的属性是用于匹配正则表达式中包含括号的子串。例举1：str = &#39;https://baidu.com/abc/test/home&#39;; reg = /(https|http):\\/\\/baidu.com\\/(.*)/; str.match(reg); 打印：RegExp.$1 // httpsRegExp.$2 // abc/test/homeRegExp.$3 // ‘’分析原因：reg正则表达式中第一个括号中的规则匹配到的str中的内容是‘https’；reg正则表达式中第二个括号中的规则匹配到的str中的内容是‘abc/test/home’；没有第三个括号，所以RegExp.$3匹配的内容为空。 常用于replace中进行匹配：var re = /(\\w+)\\s(\\w+)/; var str = &#39;John Smith&#39;; str.replace(re, &#39;$2, $1&#39;); // &quot;Smith, John&quot; RegExp.$1; // &quot;John&quot; RegExp.$2; // &quot;Smith&quot; 该特性是非标准的，请尽量不要在生产环境中使用它！ $&amp; 符title.replace(reg, ‘$&amp;‘);&amp;$可替换reg匹配中的内容； (?=p)断言位置的方法(?=p)表示匹配字母p前面的位置，例如：reg = /(?=y)/; str = “your you”;str.replace(reg, “aa”); // aayour you (?!p)是(?=p)的取反，比如(?!^)表示不匹配开始的位置。 反向引用：\\1反向引用可以方便的进行重复字符组的查找，比如/(.)\\1/可以匹配任意重复的两个字符。 \\b单词边界，\\B非单词边界","categories":[],"tags":[{"name":"RegExp","slug":"RegExp","permalink":"http://yoursite.com/tags/RegExp/"}]},{"title":"ES6语法","slug":"ES6语法","date":"2019-07-30T10:44:10.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/07/30/ES6语法/","link":"","permalink":"http://yoursite.com/2019/07/30/ES6语法/","excerpt":"async await与forEach的爱恨情仇async函数和await关键字async和await是由ES7提供的函数和关键字，async用于声明一个异步函数，await强制其他异步代码等待promise请求结果返回（相当于then的用法），但不能放在普通函数中使用，只能用在async函数里面使用。async function myFunction() { try { await requestAPromise(); } catch(err) { console.log(err);} }await最好放在try中，如果请求出错可以就进行catch捕获。 async function(db) dbFun{ docs = [{},{},{}]; docs.forEach(function(doc){ await db.post(doc); }) }报错，因为await用在了普通函数中。","text":"async await与forEach的爱恨情仇async函数和await关键字async和await是由ES7提供的函数和关键字，async用于声明一个异步函数，await强制其他异步代码等待promise请求结果返回（相当于then的用法），但不能放在普通函数中使用，只能用在async函数里面使用。async function myFunction() { try { await requestAPromise(); } catch(err) { console.log(err);} }await最好放在try中，如果请求出错可以就进行catch捕获。 async function(db) dbFun{ docs = [{},{},{}]; docs.forEach(function(doc){ await db.post(doc); }) }报错，因为await用在了普通函数中。 for循环中使用await将上述例子修改如下：async function(db) dbFun{ docs = [{},{},{}]; docs.forEach(async function(doc){ await db.post(doc); }) } 此时三个db.post(doc)是并发完成的，而不是继发执行。分享原因：forEach内部实现方法：var arr = [1, 2, 3, 4, 5] Array.prototype.forEach = function(fn){ var len = this.length; for(var i = 0; i &lt; len; i ++){ //将元素传给回调函数 fn(this[i],i); } } arr.forEach(function (ele, index){ console.log(ele, index); }) 从forEach的内部实现原理来看，实际上是在for循环中调用forEach中传入的回调函数，上述代码经过forEach的转换之后，实际上变成了async function(db) dbFun{ docs = [{},{},{}]; async function(doc){ await db.post(doc); } async function(doc){ await db.post(doc); } async function(doc){ await db.post(doc); } } 如果希望上述代码继发执行，写法如下：async function(db) dbFun{ docs = [{},{},{}]; for(let doc in docs){ await db.post(doc); }) } 如果希望多个请求并发执行，可以使用ES6的Promise.all方法。async function(db) dbFun{ docs = [{},{},{}]; return Promise.all(docs.map(function(doc){ return db.post(doc) })).then(function(result){ console.log(result); }) 对象拷贝数组拷贝 方法一123arr1 = [1, 2];arr2 = [3, 4];arr3 = [...arr1, ...arr2]; //1,2,3,4 arr3改变不会影响arr1，arr2 方法二123arr1 = [1, 2];arr2 = [3, 4];arr3 = arr1.concat(arr2); //1,2,3,4 arr3改变不会影响arr1，arr2 对象拷贝 方法一 123obj1 = &#123;a:1, b:2&#125;;obj2 = &#123;c:3, d:4&#125;;obj3 = &#123;...obj1, ...obj2&#125;; //1,2,3,4 方法二 123obj1 = &#123;a:1, b:2&#125;;obj2 = &#123;c:3, d:4&#125;;obj3 = Object.assign(&#123;&#125;, obj1, obj2); 注意assign实现的是浅拷贝，深拷贝、浅拷贝参考文档：https://juejin.im/post/59ac1c4ef265da248e75892b#heading-2","categories":[],"tags":[{"name":"ES6 JavaScript","slug":"ES6-JavaScript","permalink":"http://yoursite.com/tags/ES6-JavaScript/"}]},{"title":"图解HTTP","slug":"图解HTTP","date":"2019-07-30T10:30:10.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/07/30/图解HTTP/","link":"","permalink":"http://yoursite.com/2019/07/30/图解HTTP/","excerpt":"《图解HTTP》学习笔记请求状态码301：永久重定向；302：临时重定向；304：未修改，表示客户机缓存的版本是最新的，客户机应该继续使用它。如果客户端缓存的文件有 Last Modified ，那么会在请求中会包含 If Modified Since，这个时间就是缓存文件的 Last Modified，服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。307：临时重定向；308：永久重定向。注意：301和302这两种方法进行跳转的时候，都会将post请求改为get请求；307和308这两种方法进行重定向，禁止改变请求方法。","text":"《图解HTTP》学习笔记请求状态码301：永久重定向；302：临时重定向；304：未修改，表示客户机缓存的版本是最新的，客户机应该继续使用它。如果客户端缓存的文件有 Last Modified ，那么会在请求中会包含 If Modified Since，这个时间就是缓存文件的 Last Modified，服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。307：临时重定向；308：永久重定向。注意：301和302这两种方法进行跳转的时候，都会将post请求改为get请求；307和308这两种方法进行重定向，禁止改变请求方法。 location该字段配合3xx的响应，将提供重定向的URI。 catch-controlno-catch：强制进行服务端校验；no-store：不对资源进行缓存；max-age：失效前的最大期限； cookie和sessionCookieCookie 技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie 值后发送出去。 Set-Cookie字段的属性 nameCookie中属性的名称； value属性对应的值； expiresCookie的expires 属性指定浏览器可发送Cookie 的有效期。当省略expires 属性时，Cookie仅在浏览器关闭之前有效。 pathCookie 的path 属性可用于限制指定Cookie 的发送范围的文件目录。若不指定，则默认为文档所在文件目录。 domain通过Cookie的domain属性指定的域名可做到与结尾匹配一致。比如， 当指定http://example.com 后， 除http://example.com 以外，Example Domain或www2.example.com等都可以发送Cookie。因此，除了针对具体指定的多个域名发送Cookie 之外，不指定domain 属性显得更安全。 secureCookie 的secure 属性用于限制Web 页面仅在HTTPS 安全连接时，才可以发送Cookie。当省略secure 属性时，不论HTTP 还是HTTPS，都会对Cookie 进行回收。 HttpOnly添加改属性之后，通常从Web页面内还可以对Cookie 进行读取操作。但使用JavaScript 的document.cookie 就无法读取附加HttpOnly 属性后的Cookie 的内容了。因此，也就无法在XSS 中利用JavaScript 劫持Cookie 了。 接下来，以client指代客户端，server指代服务端，说明一个 cookie 的整个作用机制：产生 cookie：client 第一次访问 server，server 在响应头中设置一个 cookie 返回给 client，cookie 的内容为要保存的数据；保存 cookie：client 在接收到 server 返回的 cookie 后，将 cookie 保存下来,并给cookie一个有效期，过了有效期，cookie 就会失效。传递 cookie：client 再次访问 server 将会在请求头中带上保存的 cookie，将 cookie 传递到 server；解析 cookie：server 得到 client 传递的 cookie 之后，会解析 cookie，然后将相应的信息返回给 client；在 cookie 没有失效之前，cookie 的使用都是围绕2,3,4三部分来进行的，第1步一般只需要进行一次。 通过Cookie来管理SessionSession 是存储在服务器端的，避免了在客户端Cookie中存储敏感数据。 Session 可以存储在HTTP服务器的内存中，也可以存在内存数据库（如redis）中， 对于重量级的应用甚至可以存储在数据库中。 我们以存储在redis中的Session为例，还是考察如何验证用户登录状态的问题。 用户提交包含用户名和密码的表单，发送HTTP请求。服务器验证用户发来的用户名密码。如果正确则把当前用户名（通常是用户对象）存储到redis中，并生成它在redis中的ID。 这个ID称为Session ID，通过Session ID可以从Redis中取出对应的用户对象， 敏感数据（比如authed=true）都存储在这个用户对象中。 向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID。客户端接收到从服务器端发来的Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID 也随之发送到服务器。服务器收到此后的HTTP请求后，发现Cookie中有SessionID，进行篡改验证。如果Session ID 被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上httponly 属性。如果通过了验证，根据该ID从Redis中取出对应的用户对象， 查看该对象的状态并继续执行业务逻辑。 Session 代表着服务器和客户端一次会话的过程，当客户端关闭会话，或者 Session 超时失效时会话结束。 使用Cookie和Session一般情况下，Cookie数据存在本地，Session数据存在服务器端。以添加购物车为例。未登录情况下：购物车数据存在Cookie中；登录情况下：购物车数据存在Session中。cookie：优点：数据保存在用户浏览器中，不占用服务端内存；用户体检效果好；代码实现简单；缺点：cookie的存储空间只有4k；更换设备时，购物车信息不能同步；cookie禁用，不提供保存。session：优点：数据能够持久化；实现了购物车同步；缺点：增加了数据库的压力，速度慢。 拓展Cookie和token的区别Cookie： 验证有状态，验证记录或者会话需要一直在服务端和客户端保持； 登录验证之后session存在服务器端，session ID 存在客户端的Cookie中。一旦用户登出，则 session 在客户端和服务器端都被销毁。 能够处理单域和子域，但是遇到跨域的问题就会变得难以处理。 cookie无法抵御csrf（跨站点请求伪造）攻击，因为在post请求的瞬间，cookie会被浏览器自动添加到请求头中，参考文献1。 Token： 验证无状态，因为用户的状态在服务端的内存中是不存储的，所以这是一种无状态的认证机制。服务器不记录哪些用户登录了或者哪些 JWT 被发布了，而是每个请求都带上了服务器需要验证的token，token 存储在客户端，大多数通常在 local storage，也可以存在Cookie中。 一旦用户登出，token 在客户端被销毁，不需要经过服务器端。 token 的 CORS 可以很好的处理跨域的问题。由于每次发送请求到后端，都需要检查 JWT，只要它们被验证通过就可以处理请求，这使得用从myapp.com获取的授权向myservice1.com和myservice2.com获取服务成为可能。 token可以防止csrf攻击，客户端发送网络请求(一般不是登录请求)的时候，就会将token的值附带到参数中发送给服务器。如果是跨站点访问的网站，则无法拿到该token。 token比较大，如果 token 中包含很多声明，那问题就会变得比较严重。 【参考文献1】：https://zhuanlan.zhihu.com/p/27669892【参考文献2】：https://juejin.im/post/5a7c6c415188257a780da590【参考文献3】：https://cloud.tencent.com/developer/article/1130355【参考文献4】：https://www.jianshu.com/p/af8360b83a9f?spm=a2c4e.11153940.blogcont654868.10.7c1e280fzh7Wm5","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"搭建GitHub博客","slug":"hexo搭建GitHub博客","date":"2019-07-29T01:00:47.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/07/29/hexo搭建GitHub博客/","link":"","permalink":"http://yoursite.com/2019/07/29/hexo搭建GitHub博客/","excerpt":"","text":"hexo发布博客命令hexo g // 生成静态文件 hexo deploy // 将网站部署到服务器 上面两个命令可以合并成 hexo g -d hexo g --watch // 编译修改过的文件 hexo n &lt;文件名&gt; // 新建文件 hexo server // 启动server预览本地文件 hexo官方文档：https://hexo.io/zh-cn/docs/commands#generate","categories":[],"tags":[{"name":"hexo github","slug":"hexo-github","permalink":"http://yoursite.com/tags/hexo-github/"}]},{"title":"本地搭建http服务遇到的问题","slug":"本地搭建http服务","date":"2019-07-29T00:59:43.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/07/29/本地搭建http服务/","link":"","permalink":"http://yoursite.com/2019/07/29/本地搭建http服务/","excerpt":"本地打开的html文件无法访问server层接口 问题描述：在本地发起一个node server层服务，并监听3000端口号，然后直接打开本地的html文件，访问server层接口的时候报错； 原因分析：浏览器无法支持通过file协议执行http请求。 解决方案：npm安装http-server包，将本地html文件通过http server的形式打开。执行完npm install http-server -g后，在html文件目录下执行hp -o -p 8888，其中-o表示启动服务后打开浏览器，-p表示设置端口号。（注意：http服务和server层启动的服务不能使用同一个端口号）npm包地址：https://www.npmjs.com/package/http-server","text":"本地打开的html文件无法访问server层接口 问题描述：在本地发起一个node server层服务，并监听3000端口号，然后直接打开本地的html文件，访问server层接口的时候报错； 原因分析：浏览器无法支持通过file协议执行http请求。 解决方案：npm安装http-server包，将本地html文件通过http server的形式打开。执行完npm install http-server -g后，在html文件目录下执行hp -o -p 8888，其中-o表示启动服务后打开浏览器，-p表示设置端口号。（注意：http服务和server层启动的服务不能使用同一个端口号）npm包地址：https://www.npmjs.com/package/http-server http-server无法跨域请求node-server层接口 问题描述：访问接口的时候浏览器报错。 原因分析：由于http server和node server不能使用同一个端口号，所以存在跨域请求的的问题，AJAX有同源使用的限制。（协议、域名、端口号三者都相同属于同源，否则属于跨域请求）。 解决方案： 通过CORS（Cross-origin resource sharing）方式解决在node层发起服务的头部信息里加上“Access-Control-Allow-Origin”: “*”或者“Access-Control-Allow-Origin”: “http://127.0.0.1:8080（html文件打开地址）”。参考：http://www.ruanyifeng.com/blog/2016/04/cors.html JSONP的方式解决 阻止浏览器对跨域请求的拦截在终端输入 open -n /Applications/Google\\ Chrome.app/ –args –disable-web-security –user-data-dir=/Users/hzr/MyChromeDevUserData/，其中–user-data-dir表示文件存放的根目录，只需要替换“MyChromeDevUserData/”前面的内容即可（注意这里使用的是mac，window可能不一样）。","categories":[],"tags":[{"name":"node server http","slug":"node-server-http","permalink":"http://yoursite.com/tags/node-server-http/"}]},{"title":"你不知道的JavaScript","slug":"你不知道的JavaScript","date":"2019-07-04T15:15:51.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/07/04/你不知道的JavaScript/","link":"","permalink":"http://yoursite.com/2019/07/04/你不知道的JavaScript/","excerpt":"《你不知道的JavaScript》学习笔记立即执行函数(function(){···})() 或者(function(){···}())立即执行函数只能包含···所代表的作用域，不会污染外部作用域。 匿名和具名函数匿名函数写起来简洁，比如setTime()里我们常使用匿名函数，但是有一下几个缺点： 匿名函数在站追踪中不会显示出有意义的函数名，使调试变得困难； 如果没有函数名，匿名函数引用自身时只能使用过期的arguement.callee（递归中使用arguement.callee会获取到一个不同的this值，所以不推荐使用）； 匿名函数省略了对代码的可读性。所以，给函数表达式一个名称是最佳实践。","text":"《你不知道的JavaScript》学习笔记立即执行函数(function(){···})() 或者(function(){···}())立即执行函数只能包含···所代表的作用域，不会污染外部作用域。 匿名和具名函数匿名函数写起来简洁，比如setTime()里我们常使用匿名函数，但是有一下几个缺点： 匿名函数在站追踪中不会显示出有意义的函数名，使调试变得困难； 如果没有函数名，匿名函数引用自身时只能使用过期的arguement.callee（递归中使用arguement.callee会获取到一个不同的this值，所以不推荐使用）； 匿名函数省略了对代码的可读性。所以，给函数表达式一个名称是最佳实践。 函数作用域 属于这个函数的全部变量都可以在整个函数范围内使用。 123456function foo(a)&#123; var b=1; function bra() &#123; // 这里面也可以使用b &#125;&#125; 块级作用域通常情况下JavaScript不存在块级作用域，像下面这行代码：12345if()&#123; var bar = 2; console.log(bra); //2&#125; console.log(bra); //2 在if的内部通过var定义的变量，在外边仍然可以使用。 es6语法下的块级作用域：let关键字将变量绑定在任意作用域中（通常是{···}内部）12345if()&#123; let bar = 2; console.log(bra); //2&#125; console.log(bra); //ReferenceError 变量提升 引擎会在解释JavaScript代码之前首先对其进行编译，编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将他们关联起来。所以，包括变量在内的所有声明都会在代码被执行前首先被处理。 思考以下代码：123a = 2; var a; console.log(a); 打印：2分析原因：上述代码的处理顺序实际上是：123var a; a = 2; console.log(a); 因为引擎会先对变量做预解析，然后再赋值。 再来看一组例子:foo(); function foo() { console.log(a); var a=1; }打印：undefined分析原因：上述代码的处理顺序实际上是：function foo() { var a; console.log(a); a=1; } foo(); foo函数声明被提升了，因此可以先调用，再声明。函数里变量a的声明虽然也被提升，但打印之前并没有被赋值，所以回报undefined。另外注意，函数表达式并不会被提升。 foo(); var foo = function bar() { ··· }打印：TypeError分析原因：上述代码的处理顺序实际上是：var foo; foo(); foo = function () {}虽然foo已经被定义了，但是被没有赋值，foo的值相当于是undefined，当对undefined进行函数调用的时候，会导致非法操作，因此抛出TypeError。 注意：函数声明和变量声明都会被提升，但是函数会先被提升，然后才是变量。如果是重复声明的var，则会被忽略，但是如果是重复声明的函数，则后面的声明会覆盖前面的声明。 undefined、ReferenceError、TypeErrorundefined: 定义了某个变量，但是却没有赋值，会报undefined，它是JavaScript原始数据类型。var a; console.log(a); //undefinedReferenceError: 当尝试引用一个未定义的变量时，会报改错。console.log(b); //Uncaught ReferenceError: b is not definedTypeError: 当传入函数的操作数或参数的类型并非操作符或函数所预期的类型时，将抛出一个 TypeError 类型错误。var fn; fn(); //Uncaught TypeError: fn is not a function 作用域闭包什么是闭包?函数发生在本身的词法作用域以外执行，就产生了闭包。 123456789function foo() &#123; var a=2; function bar() &#123; console.log(a); &#125; return bar;&#125; var baz = foo();baz(); //2 关于this this是在运行时进行绑定的，不是在编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数的声明位置没有任何关系，只取决于函数的调用方式。 更正：书中this一章中的1.2.2节中，有一段代码经过验证，和书中给的结果不太一致，代码如下：12345678function foo() &#123; var a =2; this.bar();&#125; function bar() &#123; console.log(this.a); &#125; foo(); 打印结果：undefined书中给的结果是ReferenceError: a is not defined实际上这里的this指向的是window，如果window上面没有某个对象的话，都会输出undefined，所以这里的this.a也会输出undefined。 this全面解析 this的绑定规则分为四种：默认绑定、隐式绑定、显示绑定、new绑定 默认绑定 不带任何修饰的函数引用进行调用的。 例举1：var a = 1; function foo() {console.log(a);} foo()打印：1 例举2：var name = &quot;The Window&quot;; var object = { name : &quot;My Object&quot;, getNameFunc : function(){ return function(){ return this.name; }; } };console.log(object.getNameFunc()());打印：The Window分析原因：object.getNameFunc()执行之后实际上返回一个匿名函数，第二个括号表示执行这个匿名函数。返回的函数会先在自己的作用域内查找name变量，如果没有找到，则会到window对象上查找。 隐式绑定 当函数引用有上下文对象时，或者说被某个对象拥有或者包含，这个时候会产生隐式引用。 例举1：var a=1; function foo() {console.log(this.a)} var obj = {a:2, foo: foo}; obj.foo();打印：2分析原因：当调用foo函数的时候，它的前面加上了对obj的引用。 例举2：123456var arr = [1, 2, 3, 4, 5];Array.prototype.myForEach = function()&#123; var len = this.length; console.log(this);&#125;arr.myForEach(); 打印：[1, 2, 3, 4, 5];分析原因：myForEach方法被挂载在arr这个数组上，所以其内部的this指向arr数组。 注意一种情况：隐式丢失。var a=1; function foo() {console.log(this.a)} var obj = {a:2, foo: foo}; var fn = obj.foo;fn();打印：1分析原因：fn实际上是对foo函数的直接引用，此时fn实际上是一个不带任何修饰的函数调用，应用了默认绑定。注意，参数传递其实也隐藏了是一种赋值，会进行默认绑定。 显示绑定 如果想在某个对象上强制调用某个函数，那么称之为显示绑定。call，apply可以提供显示绑定方法。 例举1：function foo() {console.log(this.a)} obj={a:1}; foo.call(obj);打印：1 new绑定 使用new来调用函数时，可以影响函数this的绑定行为。 例举1：12345function foo(a)&#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a); 打印：2 几种绑定关系的优先级 显示绑定 &gt; 隐式绑定 new绑定 &gt; 隐式绑定 new绑定 &gt; 显示绑定 es6箭头函数中this的指向 箭头函数的this是在定义函数时绑定的，不是在执行过程中绑定的。简单的说，函数在定义时，this就继承了定义函数的对象。一旦确定了箭头函数的this指向，就无法进行修改。 例举1：123456789function foo() &#123; return (a) =&gt; &#123; console.log(this.a); &#125;&#125;var obj1 = &#123; a:2 &#125;;var obj2 = &#123; a:3 &#125;;var bar = foo.call(obj1);bar.call(obj2); 打印：2 例举2：12345678function foo() &#123; setTimeout(()=&gt;&#123; console.log(this.a) &#125;, 1000)&#125;var obj = &#123;a:1&#125;;var a = 2;foo.call(obj); 打印：1 如果将例举2中setTimeOut中的回调函数从箭头函数改为普通函数呢？12345678function foo() &#123; setTimeout(function()&#123; console.log(this.a) &#125;, 1000)&#125;var obj = &#123;a:1&#125;;var a = 2;foo.call(obj); 打印：2分析原因：异步函数的回调函数如果是普通函数（非箭头函数），则函数的this指向window。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"高性能JavaScript","slug":"高性能JavaScript","date":"2019-07-04T15:09:46.000Z","updated":"2019-10-15T14:29:08.000Z","comments":true,"path":"2019/07/04/高性能JavaScript/","link":"","permalink":"http://yoursite.com/2019/07/04/高性能JavaScript/","excerpt":"《高性能JavaScript》学习笔记JavaScript加载与执行 JavaScript代码的下载和执行经常会阻塞浏览器的其他进程，从而带来严重的用户体验问题，管理好JavaScript代码是提高web性能的关键。 减少JavaScript对性能影响的方法： &lt;/body&gt;闭合标签之前，将所有&lt;script&gt;标签放在页面底部。由于浏览器在解析到标签之前，不会渲染页面的任何内容，如果把script脚本放在页面顶部加载，将会导致页面明显延迟。 合并脚本页面中&lt;script&gt;标签越少，加载越快。比如下载单个100KB的文件，比下载4个25KB的文件更快，因为每一次HTTP请求都会带来额外的性能开销。虽然很多浏览器已经支持并行下载，但并行下载的文件数量有限。","text":"《高性能JavaScript》学习笔记JavaScript加载与执行 JavaScript代码的下载和执行经常会阻塞浏览器的其他进程，从而带来严重的用户体验问题，管理好JavaScript代码是提高web性能的关键。 减少JavaScript对性能影响的方法： &lt;/body&gt;闭合标签之前，将所有&lt;script&gt;标签放在页面底部。由于浏览器在解析到标签之前，不会渲染页面的任何内容，如果把script脚本放在页面顶部加载，将会导致页面明显延迟。 合并脚本页面中&lt;script&gt;标签越少，加载越快。比如下载单个100KB的文件，比下载4个25KB的文件更快，因为每一次HTTP请求都会带来额外的性能开销。虽然很多浏览器已经支持并行下载，但并行下载的文件数量有限。 使用无阻塞方式下载JavaScript 带有defer、async属性的script，允许js资源与页面中的其他资源并行下载，不会阻塞浏览器其他进程。但是带有async属性的script，会在js脚本下载完成之后马上执行，此时脚本的执行会阻塞页面进程；而带有defer属性的script下载完js脚本后，会等到页面所有元素解析完成之后，onload事件处理器执行之前执行js脚本，不会阻塞页面进程。（注意：defer属性仅当src属性声明时才生效————-测一测） 动态创建脚本元素动态创建&lt;script&gt;标签的方法，无论何时启动下载，文件的下载和执行都不会阻塞页面其他进程，但是动态加载的文件会按照从服务器返回的顺序下载和执行脚本，也就是说不一定能按照指定的顺序执行。因为浏览器对动态插入的script默认设置了async（各个浏览器可能不同），而async的执行是没有顺序的，所以我们把script标签的async属性改成false就可以了。（参考：http://echizen.github.io/tech/2017/04-22-script-exec） 使用XML对象下载JavaScript代码。 数据存储 JavaScript中，数据存储位置会对代码整体性能产生重大影响。数据存储共有4种方式：字面量、变量、数组、对象。 存储方式解析： 访问字面量和局部变量的速度比访问数组和对象的速度快。 访问局部变量比访问全局变量更快局部变量存在作用域链的起始位置，代码执行过程中，会先查找局部变量，没有找到，就会根据作用域链依次往上查找，因此变量在作用域链中的位置越深，访问的时间越长。全部变量存在执行环境作用域的最末端，因此最远。如果某个跨作用域的值或全局变量被引用一次以上，我们可以将这个值存储在当前执行环境的局部变量里，比如： 12345678910111213function setStyle() &#123; let doc = document; // 将document对象存在局部变量doc里 let div = doc.getElementById('app'); let span = doc.getElementsByTagName('text'); let len = span.length; div.onClick = function() &#123; // &#125; for(let i=0; i&lt;len; i++) &#123; update(span[i]); &#125;&#125; 访问局部变量比访问全局变量更快尽量减少使用嵌套成员，嵌套的越少，越影响性能，比如执行window.location.href总比location.href要慢。我们可以将对象成员、数组元素等保存在局部变量中使用，例如： 123456function getAttribute() &#123; let doc = document; let name = doc.getElementById('name'); let age = doc.getElementById('age'); let sex = doc.getElementById('sex');&#125; 改写如下： 1234567function getAttribute() &#123; let doc = document; let getId = doc.getElementById; // 将doc.getElementById对象存储在局部变量中，减少读取对象成员的次数 let name = getId('name'); let age = getId('age'); let sex = getId('sex');&#125; DOM编程 有一个比喻，ECMAScript和DOM好比两座岛屿，他们之间用收费桥梁连接，ECMAScript每次访问DOM，都要途径这座桥，并缴纳过桥费，访问DOM次数越多，费用就越高。所以减少DOM操作次数，能有效提高页面的响应速度。 操作DOM修改思考以下代码：12345function innerHTMLLoop() &#123; for(let count=0; count&lt;1000; count++) &#123; document.getElementById('app').innerHTML = document.getElementById('app').innerHTML + '1'; &#125;&#125; 每循环一次，该DOM元素都会被访问两次，十分影响性能，换一下方式，用局部变量存储的方式改下，如下：1234567function innerHTMLLoop() &#123; let content = ''; for(let count=0; count&lt;1000; count++) &#123; content += '1'; &#125; document.getElementById('app').innerHTML = document.getElementById('app').innerHTML + content;&#125; 改写后代码的运行速度能明显提升。 HTML集合HTML集合是包含DOM节点引用的类数组对象，它不是真正的数值，但是含有数组中的length属性，还能以数字索引的方式访问列表中的元素。思考以下代码：1234let allDivs = document.getElementsByTagName('div');for (let i=0; i&lt;allDivs.length; i++) &#123; document.body.appendChild(document.createElement('div'));&#125; 分析：根据前面“数据存储”章节的讲解，上面这段代码首先访问了三次document这个全局对象，可以优化为一个局部变量。然后我们来看循环中的allDivs.length。实际上HTML集合一直与文档保持着连接，即能实时获取到文档的更新，每次文档一更新，HTML集合也会跟随改变。这段代码看上去是把div的数量翻倍，每循环一次，body里添加一个新的div，但实际上这是一个死循环。因为allDivs这个集合事实与文档保持着连接，当文档中div的数量增加时，allDivs.length实际上也会一起增加，循环永远无法退出。 上面的代码可以改写如下：123456let doc = document; // 将全部对象保存在局部变量里let allDivs = doc.getElementsByTagName('div');let len = allDivs.length; // 把集合的长度保存在局部变量里for (let i=0; i&lt;len; i++) &#123; doc.body.appendChild(doc.createElement('div'));&#125; 另外，变量数组比遍历集合快，可以将集合元素拷贝到数组中再进行遍历。 快速选取DOMDOM提供了多种方法来读取文档的特定结构，我们最好为特定操作选择高效的api。比如选择子节点，childNodes不会区分元素节点和其他类型的节点，比如注释和文本节点等（HTML中的空白、换行其实是文本节点），如果我们只想访问元素节点，那么用children会更高效，不需要做额外的过滤处理。 另一方面，使用CSS选择器也是定位节点的一种方式。推荐两个高效的原生DOM方法：querySelect()和querySelecterAll()。 querySelect() 方法返回文档中匹配指定 CSS 选择器的第一个元素。 querySelectorAll() 方法返回文档中匹配指定 CSS 选择器的所有元素，返回 NodeList 对象。此时的NodeList对象是静态的，所以返回的节点不会对应实时的文档结构。（注意：childNodes返回的NodeList对象是动态的,会随着文档结构的变化而变化）但是如果只是单纯的根据tag name来查找元素，建设使用getElementsByTagName()方法，因为getElementsByTagName()方法返回的HTML集合是动态的，动态集合比静态更快能够更快的被创建和返回。（参考：https://blog.csdn.net/renfufei/article/details/41088521） 思考题：找出页面中class=”warning”或class=”notice”的div元素。考虑一下代码：1let errs = document.querySelectAll('div.warning, div.notice'); 如果不使用querySelectAll，要获得同样的结果，会更加复杂。 重绘与重排 当DOM的变化影响了元素的几何属性（宽和高）的时候，就会引起页面重绘和重排。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树，这个过程称为“重排”；完成重排之后，浏览器会重新绘制受影响的部分到屏幕中，这个过程称为“重绘”。重绘和重排是代价昂贵的操作，它们会导致web应用程序UI反应迟钝。 下面几种情况会引起页面重排： 添加或删除可见的DOM元素。 改变普通文档流中元素的位置。 改变元素尺寸（包括：外边距、内边距、边框宽度、厚度、高度等属性）。 内容改变，例如：文本改变、图片改变（尺寸不一样的图片）。 页面渲染器初始。 浏览器窗口改变。 出现滚动条（会引起整个页面的重排）。 为了提高web性能，大多数浏览器会通过队列化修改并批量执行来优化重排过程，但是修改样式的过程中如果用户获取了布局信息，就会导致浏览器立即执行队列中的任务，即无法等到批量执行，然后触发重排以返回正确值，例如以下代码：123456789let computed = window.getComputedStyle('document.body', '');let style = document.body.style;let tem = '';style.color = 'red';tem = computed.height;style.color = 'green';tem = computed.width;style.color = 'yellow';tem = computed.background; 示例中，body元素改变了三次color值，且每改变一次都读取一个computed样式属性，虽然读取的属性都与改变的样式无关，但是浏览器却需要刷新渲染队列和重排，因为computed样式属性被请求了。一个更高效的方法是，不要在布局信息改变的时候查询它，以上代码改写如下：123456789let computed = window.getComputedStyle('document.body', '');let style = document.body.style;let tem = '';style.color = 'red';style.color = 'green';style.color = 'yellow';tem = computed.height;tem = computed.width;tem = computed.background; 批量处理样式 通过cssText批量设置属性 12let el = document.getElementById('app');app.style.cssText = 'height: 100px; width: 200px; color: green;'; cssText属性可以合并所有的样式改变一次处理，这样只会修改一次DOM。但是cssText属性会覆盖已有的样式信息，如果想要保留已有样式，可以把需要变更的样式附加在cssText字符串后面，上面的代码改写如下： 12let el = document.getElementById('app');app.style.cssText += '; height: 100px; width: 200px; color: green;'; 参考文档：https://cloud.tencent.com/developer/article/1057545 通过改变DOM中class的值来改变样式 批量修改DOM当需要对DOM元素进行一系列操作时，可以通过以下步骤减少重排和重绘的次数： 使元素脱离文档流； 对其应用多重改变； 把元素带回文档中。 下面有三种基本方法可以使用。 隐藏元素，应用修改，然后重新显示； 1234let el = document.getElememtById('app');el.style.display = 'none';···（执行修改DOM的操作，比如追加元素）el.style.display = 'block'; 使用文档片段； 123let fragment = document.createDocumentFragment();···（执行修改DOM的操作，比如追加元素）document.getElementById('app').appendChild(fragment); 因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。 将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后在替换成原始元素。 算法和流程控制 改善循环性能的最佳方式是减少每次迭代的运算量和减少循环迭代次数。另外需要注意，避免使用for-in循环，因为该循环会同时搜索实例和原型属性，产生更多开销。除非需要遍历一个属性数量未知的对象。 减少迭代工作量 比如遍历数组的时候，不要将数组的长度计算放在for循环中，可以将数组的长度作为局部变量存储起来，这样只用对数组长度进行一次属性查找。 通过颠倒数组的顺序来提高循环性能，思路以下代码： 123for(let i=0, len = arr.length; i&lt;len; i++) &#123; // 其他操作&#125; 这样每次循环的时候需比较：1、len的值是否小于数组长度；2、查看控制条件的结果是否为true（i&lt;len === true）。如果将以上代码改写如下： 123for(len = arr.length; i--;) &#123; // 其他操作&#125; 这样每次循环的时候只需判断控制条件的结果是否为true。随着迭代次数的增多，性能提升的趋势会更趋明显。 减少迭代次数即使在循环体内执行最简洁的代码，累计迭代上千次，运行速度也会慢下来，减少迭代次数能获得显著的性能提升。“达夫设备（Duff’s Device）”是一种广为人知的限制循环迭代次数的模式。123456789101112131415161718function useDuffDevice(arr)&#123; var len=arr.length, j=len%8; while(j)&#123; process(arr[j--]); &#125; j=Math.floor(len/8); while(j--)&#123; process(arr[j--]); process(arr[j--]); process(arr[j--]); process(arr[j--]); process(arr[j--]); process(arr[j--]); process(arr[j--]); process(arr[j--]); &#125;&#125; 基于函数的迭代比如forEach是一个便利的迭代方法，但它比基于循环的迭代要慢，对每个数组调用外部方法所带来的开销是速度慢的主要原因，因此在运行速度严格时，尽量避免使用基于函数的迭代方法。 优化if-else 大概率的条件放前面判断。 使用二分法的方式判断条件。 Memoization优化技术Memoization是一种避免重复工作的方法，它缓存前一个计算的结果供后续使用，避免了重复计算，在递归算法中十分有用。下面是一段利用Memoization技术实现阶乘算法的示例：123456789101112function memfactorial(n) &#123; if(!memfactorial.catch) &#123; memfactorial.catch = &#123; \"0\": 1, \"1\": 1 &#125; &#125; if(!memfactorial.catch.hasOwnProperty(n)) &#123; memfactorial.catch[n] = n * memfactorial(n-1); &#125; return memfactorial.catch[n];&#125; 解析：在计算一个阶乘之前先检查这个缓存对象是否已经存在相应的计算结果，没有的话则认为是第一次计算，计算完成之后，结果被存储在缓存中供以后使用。比如计算完memfactorial(5)之后，再计算memfactorial(4)就可以直接从缓存中取，不需要重新计算。 字符串和正则表达式字符串需要大量循环叠加字符串的时候，可以利用数组项合并的方法，比如：1234567let str = 'string';let arr = [];let num = 5000;while(num--) &#123; arr[arr.length] = str;&#125;let newStr = arr.join(''); 正则表达式","categories":[],"tags":[{"name":"JavaScript Web","slug":"JavaScript-Web","permalink":"http://yoursite.com/tags/JavaScript-Web/"}]}]}